{"version":3,"sources":["webpack://markup/webpack/bootstrap","webpack://markup/./src/img/redline_marker.svg","webpack://markup/./src/js/L.Control.Markup.js"],"names":[],"mappings":";;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;AClFA,0pBAA0pB,kBAAkB,UAAU,sBAAsB,iBAAiB,mBAAmB,2PAA2P,kBAAkB,UAAU,iBAAiB,iBAAiB,+OAA+O,kBAAkB,UAAU,iBAAiB,iBAAiB,iPAAiP,kBAAkB,UAAU,iBAAiB,iBAAiB,6KAA6K,4BAA4B,UAAU,sBAAsB,oBAAoB,oBAAoB,sBAAsB,oBAAoB,iBAAiB,eAAe,YAAY,gGAAgG,UAAU,sBAAsB,oBAAoB,oBAAoB,sBAAsB,oBAAoB,iBAAiB,eAAe,YAAY,qIAAqI,UAAU,sBAAsB,oBAAoB,oBAAoB,sBAAsB,oBAAoB,iBAAiB,eAAe,YAAY,uC;;;;;;;;;;;;ACA7gF;AAAA;AAAA;AAAuD;;AAEvD;AACA;;AAEA;AACA;AACA,gDAAgD,0BAA0B,UAAU,IAAI;AACxF,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL,sCAAsC,qBAAqB,KAAK;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,SAAS;AACT,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,wBAAwB,GAAG,yBAAyB,G;AACzG;;AAEA,gEAAgE,qBAAqB;;AAErF;AACA;AACA;AACA,0CAA0C,gBAAgB,8DAAc;;AAExE;AACA;AACA;AACA;AACA;AACA,yDAAyD,QAAQ;AACjE,wEAAwE,mBAAmB;AAC3F;AACA,SAAS;;AAET,qDAAqD,aAAa;;AAElE;AACA;AACA,SAAS;AACT,KAAK;;AAEL;AACA,+CAA+C,gBAAgB;AAC/D,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,iDAAiD,2BAA2B;AAC5E;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;;AAGL;;AAEA;AACA;AACA,SAAS;AACT,KAAK;;AAEL;AACA;AACA;AACA,SAAS;AACT,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;;AAEA;;AAEA;AACA;AACA,SAAS;;;AAGT;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,S;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iEAAiE,mDAAmD;AACpH;AACA;AACA,+DAA+D,mDAAmD;AAClH;AACA;AACA,oEAAoE,mDAAmD;AACvH;AACA;AACA,iEAAiE,mDAAmD;AACpH;AACA;AACA,+DAA+D,mDAAmD;AAClH;AACA;AACA,4DAA4D,mDAAmD;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qCAAqC,aAAa,EAAE;AACpD;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC;AAClC;;AAEA;AACA;AACA;AACA,SAAS;;AAET;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,K;;AAEA;AACA;AACA,K;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,iCAAiC;AACjC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,iCAAiC;AACjC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC;AACjC;;AAEA;;;AAGA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,aAAa;;AAE3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wBAAwB,OAAO;AACtD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC;AACjC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iCAAiC;AACjC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,iCAAiC;AACjC,4B;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,iCAAiC;AACjC;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mCAAmC,iB;;AAEnC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA,W;AACA,qCAAqC,MAAM;AAC3C,mC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA,sBAAsB,mCAAmC;AACzD;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,YAAY;AAClC;;AAEA;;AAEA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iCAAiC;AACjC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA","file":"L.Control.Markup.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/js/L.Control.Markup.js\");\n","module.exports = \"<svg xmlns:dc=\\\"http://purl.org/dc/elements/1.1/\\\" xmlns:cc=\\\"http://creativecommons.org/ns#\\\" xmlns:rdf=\\\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\\\" xmlns:svg=\\\"http://www.w3.org/2000/svg\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" id=\\\"svg8\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 100 100\\\" height=\\\"50px\\\" width=\\\"50px\\\"><defs id=\\\"defs2\\\"><marker id=\\\"Arrow2Lend\\\" refX=\\\"0.0\\\" refY=\\\"0.0\\\" orient=\\\"auto\\\" overflow=\\\"visible\\\"><path transform=\\\"scale(1.1) rotate(180) translate(1,0)\\\" d=\\\"M8.7185878 4.0337352L-2.2072895 0.016013256 8.7185884-4.0017078C6.97309-1.6296469 6.9831476 1.6157441 8.7185878 4.0337352z\\\" id=\\\"path4557\\\" style=\\\"fill-opacity:1;fill-rule:evenodd;fill:#f00;stroke-linejoin:round;stroke-opacity:1;stroke-width:0.625;stroke:#f00\\\"></path></marker><marker id=\\\"Arrow1Lend\\\" refX=\\\"0.0\\\" refY=\\\"0.0\\\" orient=\\\"auto\\\" overflow=\\\"visible\\\"><path transform=\\\"scale(0.8) rotate(180) translate(12.5,0)\\\" d=\\\"M0 0L5-5 -12.5 0 5 5 0 0z\\\" id=\\\"path4539\\\" style=\\\"fill-opacity:1;fill-rule:evenodd;fill:#000;stroke-opacity:1;stroke-width:1pt;stroke:#000\\\"></path></marker><marker id=\\\"marker5370\\\" refX=\\\"0.0\\\" refY=\\\"0.0\\\" orient=\\\"auto\\\" overflow=\\\"visible\\\"><path transform=\\\"scale(0.8) translate(12.5,0)\\\" d=\\\"M0 0L5-5 -12.5 0 5 5 0 0z\\\" id=\\\"path5368\\\" style=\\\"fill-opacity:1;fill-rule:evenodd;fill:#000;stroke-opacity:1;stroke-width:1pt;stroke:#000\\\"></path></marker><marker id=\\\"Arrow1Lstart\\\" refX=\\\"0.0\\\" refY=\\\"0.0\\\" orient=\\\"auto\\\" overflow=\\\"visible\\\"><path transform=\\\"scale(0.8) translate(12.5,0)\\\" d=\\\"M0 0L5-5 -12.5 0 5 5 0 0z\\\" id=\\\"path4536\\\" style=\\\"fill-opacity:1;fill-rule:evenodd;fill:#000;stroke-opacity:1;stroke-width:1pt;stroke:#000\\\"></path></marker></defs><g transform=\\\"translate(0,-197)\\\" id=\\\"layer1\\\"><path id=\\\"path5354\\\" d=\\\"M13.435239 279.99691 2.7794681 294.40951\\\" style=\\\"fill:none;marker-end:url(#Arrow2Lend);opacity:1;stroke-dasharray:none;stroke-dashoffset:0;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-width:2;stroke:#f00;vector-effect:none\\\"></path><path id=\\\"path5778\\\" d=\\\"m2.779468 294.40951v0\\\" style=\\\"fill:none;opacity:1;stroke-dasharray:none;stroke-dashoffset:0;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-width:4;stroke:#000;vector-effect:none\\\"></path><path id=\\\"path5780\\\" d=\\\"M99.785712 246.72916 38.55357 246.35119 2.779468 294.40951\\\" style=\\\"fill:none;opacity:1;stroke-dasharray:none;stroke-dashoffset:0;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-width:3;stroke:#f00;vector-effect:none\\\"></path></g></svg>\"","import redline_marker from \"../img/redline_marker.svg\";\r\n\r\nL.Control.Markup = L.Control.extend(/** @lends L.Control.Markup.prototype */ {\r\n    includes: (L.Evented.prototype || L.Mixin.Events),\r\n\r\n    options: {\r\n        id: 'markup',\r\n        markup_select_callback: (markup_id) => { console.log(`Markup ID ${markup_id}`);},\r\n    },\r\n\r\n    initialize: function (options) {\r\n        L.setOptions(this, options);\r\n        this.markup_layer_groups = [];\r\n        this.CurrentMarkup = null;\r\n        this.canvas = null;\r\n        this.current_layer = 1;\r\n        this.OnMarkupSelected = [];\r\n    },\r\n    register_onMarkupSelected: function (callback) {\r\n        this.OnMarkupSelected.push(callback);\r\n    },\r\n    addTo: function (map) {\r\n        this._map = map;\r\n        return this;\r\n    },\r\n\r\n    remove: function (map) {\r\n        this._map = null;\r\n        return this;\r\n    },\r\n\r\n    get_layer_group: function (layer_num) {\r\n\r\n        if (!this.markup_layer_groups[layer_num]) {\r\n            this.markup_layer_groups[layer_num] = L.layerGroup();\r\n        }\r\n        return this.markup_layer_groups[layer_num];\r\n    },\r\n\r\n    show_layer: function (layer_num, { hide_layers = true } = {}) {\r\n        this.current_layer = layer_num;\r\n        if (hide_layers) {\r\n            this.hide_layer();\r\n        }\r\n        var layer = this.get_layer_group(layer_num);\r\n        layer.addTo(this._map);\r\n    },\r\n\r\n    hide_layer: function (layer_num) {\r\n        this.markup_layer_groups.forEach((layer) => {\r\n            this._map.removeLayer(layer);\r\n        });\r\n    },\r\n\r\n    add_markup: function (_markup, type = 'svg') {\r\n\r\n        var markup = Object.assign({\r\n            bounds: [[0, 0], [0, 0]],\r\n            image: '',\r\n            marker_text: '',\r\n            marker_latlng: [0,0],\r\n            layer: 0\r\n        }, _markup);\r\n\r\n        let layer = this.get_layer_group(markup.layer);\r\n        let ol;\r\n        switch (type) {\r\n            case 'image':\r\n                ol = L.imageOverlay('data:image/svg+xml;charset=utf-8,' + markup.image, markup.bounds);\r\n                layer.addLayer(ol);\r\n                break;\r\n            case 'svg':\r\n                //make SVG element\r\n                var obj = document.createElement('object');\r\n                obj.innerHTML = markup.image;\r\n                var svg = obj.querySelector('svg');\r\n                svg.setAttribute(\"viewBox\", `0, 0, ${svg.width.baseVal.value},${svg.height.baseVal.value}`); \r\n                svg.style.cursor = 'move';\r\n\r\n                ol = L.imageElementOverlay(svg, markup.bounds, { interactive: false });\r\n\r\n                layer.addLayer(ol);\r\n                break;\r\n        }\r\n        var iconSVG = 'data:image/svg+xml;base64,' + btoa(redline_marker);\r\n        \r\n        var icon = new L.DivIcon({\r\n            iconAnchor: [0, 50],\r\n            iconSize: [200, 50],\r\n            className: 'my-div-icon',\r\n            html: `<div class=\"d-flex flex-row\">\r\n                        <img class=\"my-div-image\" src=\"${iconSVG}\"/>\r\n                        <span class=\"d-flex align-items-center w-100\">${markup.marker_text}</span>\r\n                    </div>`\r\n        })\r\n\r\n        var marker = L.marker(markup.marker_latlng, { icon: icon }).addTo(layer);\r\n        \r\n        marker.on('click', (e) => {\r\n            this.markup_select_event(e, markup.id);\r\n        });\r\n    },\r\n\r\n    markup_select_event: function (e, markup_id) {\r\n        this.OnMarkupSelected.forEach((cb) => { cb(markup_id);})\r\n    },\r\n\r\n    start: function(){\r\n        this.lock_map();\r\n        this.CurrentMarkup = new Markup(this.get_canvas());\r\n    },\r\n\r\n    stop: function () {\r\n        this.unlock_map();\r\n        this.clear();\r\n    },\r\n\r\n    freeze: function () {\r\n        if (null !== this.CurrentMarkup) {\r\n            this.CurrentMarkup.SetMode('off');\r\n        }\r\n    },\r\n\r\n    clear: function () {\r\n        if (null !== this.CurrentMarkup) {\r\n            this.CurrentMarkup.Destroy();\r\n            this.remove_canvas();\r\n        }\r\n        this.CurrentMarkup = null;\r\n    },\r\n\r\n    store: function () {\r\n        if (null !== this.CurrentMarkup) {\r\n            var markup = {\r\n                marker_latlng: [this.first_point().lat, this.first_point().lng],\r\n                bounds: this.bounds(),\r\n                image: this.CurrentMarkup.SVG,\r\n                layer: this.current_layer\r\n            };\r\n            this.add_markup(markup);\r\n        }\r\n    },\r\n\r\n    clear_all: function () {\r\n        this.clear();\r\n        this.markup_layer_groups.forEach((l) => { this._map.removeLayer(l) });\r\n        this.markup_layer_groups = [];\r\n    },\r\n\r\n    remove_canvas: function () {\r\n        if (null !== this.canvas) {\r\n            this.canvas.remove();\r\n        }\r\n        this.canvas = null;\r\n    },\r\n\r\n\r\n    get_canvas: function () {\r\n        if (null === this.canvas) {\r\n            this.canvas = document.createElement(\"canvas\");\r\n            this.canvas.className = 'canvases';\r\n            this.canvas.id = 'markup-canvas';\r\n\r\n            var pane = this.get_pane();\r\n            pane.prepend(this.canvas);\r\n\r\n            this.canvas.width = this._map._container.offsetWidth;\r\n            this.canvas.height = this._map._container.offsetHeight;\r\n\r\n        }\r\n        return this.canvas;\r\n    },\r\n\r\n    get_pane: function () {\r\n\r\n        var pane = this._map.getPane('markup')\r\n        if (!pane) {\r\n            pane = this._map.createPane('markup');\r\n        }\r\n        pane.style.zIndex = 650;\r\n        return pane;\r\n    },\r\n\r\n\r\n    lock_map: function(){\r\n\r\n        this._map._handlers.forEach(function (handler) {\r\n            handler.disable();\r\n        });\r\n    },\r\n\r\n    unlock_map: function () {\r\n        this._map._handlers.forEach(function (handler) {\r\n            handler.enable();\r\n        });\r\n    },\r\n\r\n    bounds: function () {\r\n        return this._map.getBounds();\r\n    },\r\n\r\n    type: function() {\r\n        return 'redline';\r\n    },\r\n    get_svg: function () {\r\n        return this.CurrentMarkup.SVG;\r\n    },\r\n    first_point: function () {\r\n        return this._map.layerPointToLatLng([this.CurrentMarkup.FirstPoint.x, this.CurrentMarkup.FirstPoint.y]);\r\n    },\r\n    marker_point: function () {\r\n        return this._map.layerPointToLatLng([this.CurrentMarkup.MarkerPoint.x, this.CurrentMarkup.MarkerPoint.y]);\r\n    }\r\n});\r\n\r\nL.control.markup = function (options) {\r\n    return new L.Control.Markup(options);\r\n};\r\n\r\n\r\nclass Markup {\r\n    //Class to capture and control all markup types (stroke, text, shapes, etc.)\r\n    //Controls the canvas?\r\n    //exports SVG?\r\n    //stores markup state.\r\n    constructor(canvas, _opt = {}) {\r\n        if (!(this instanceof Markup)) return new Markup(_canvas);\r\n\r\n        this.canvas = canvas;\r\n\r\n        this.opts = Object.assign({\r\n            init_mode: 'stroke',\r\n        }, _opt);\r\n\r\n\r\n        this.context = this.canvas.getContext(\"2d\");\r\n\r\n        //this.context.canvas.width = this.context.canvas.clientWidth;\r\n        //this.context.canvas.height = this.context.canvas.clientHeight;\r\n\r\n        var viewportOffset = this.canvas.getBoundingClientRect();\r\n\r\n        // these are relative to the viewport, i.e. the window\r\n        this.x_offset = viewportOffset.left;\r\n        this.y_offset = viewportOffset.top;\r\n\r\n        this.modes = {\r\n            none: 'none',\r\n            stroke: 'stroke',\r\n            line: 'line',\r\n            rectangle: 'rectangle',\r\n            circle: 'circle',\r\n            text: 'text',\r\n            x: 'x',\r\n        };\r\n        this.mode = this.opts.init_mode;\r\n\r\n\r\n        this.History = [];\r\n        this.undoLevel = 0;\r\n        this._currentData = null;\r\n\r\n        this.TouchMouseHandler = (e) => {\r\n            if (null !== this.CurrentData) {\r\n                if (this._currentData.Finished) {\r\n                    this.CloseCurrentData();\r\n                }\r\n                this.CurrentData.TouchMouseHandler(e);\r\n\r\n            }\r\n        }\r\n        this.BindEvents();\r\n    }\r\n\r\n    BindEvents() {\r\n        this.canvas.addEventListener(\"mousedown\", this.TouchMouseHandler);\r\n        this.canvas.addEventListener(\"mousemove\", this.TouchMouseHandler);\r\n        this.canvas.addEventListener(\"mouseup\", this.TouchMouseHandler);\r\n        this.canvas.addEventListener(\"mouseleave\", this.TouchMouseHandler);\r\n\r\n        // Set up touch events for mobile, etc\r\n        this.canvas.addEventListener(\"touchstart\", this.TouchMouseHandler);\r\n        this.canvas.addEventListener(\"touchend\", this.TouchMouseHandler);\r\n        this.canvas.addEventListener(\"touchmove\", this.TouchMouseHandler);\r\n    }\r\n\r\n    CloseCurrentData() {\r\n\r\n        if (null !== this._currentData && this._currentData.IsValid) {\r\n            this.History = this.History.slice(0, this.History.length - this.undoLevel);\r\n            this.History.push(this._currentData);\r\n            this.undoLevel = 0;\r\n\r\n            this.DestroyCurrentData();\r\n        } \r\n    }\r\n\r\n    DestroyCurrentData() {\r\n\r\n        if (null !== this._currentData) {\r\n            this._currentData.Destroy();\r\n            this._currentData = null;\r\n        }\r\n    }\r\n\r\n    get CurrentData() {\r\n        if (null === this._currentData) {\r\n            switch (this.mode) {\r\n                case this.modes.stroke:\r\n                    this.CurrentData = new Stroke(this.context, { x_offset: this.x_offset, y_offset: this.y_offset });\r\n                    break;\r\n                case this.modes.line:\r\n                    this.CurrentData = new Line(this.context, { x_offset: this.x_offset, y_offset: this.y_offset });\r\n                    break;\r\n                case this.modes.rectangle:\r\n                    this.CurrentData = new Rectangle(this.context, { x_offset: this.x_offset, y_offset: this.y_offset });\r\n                    break;\r\n                case this.modes.circle:\r\n                    this.CurrentData = new Circle(this.context, { x_offset: this.x_offset, y_offset: this.y_offset });\r\n                    break;\r\n                case this.modes.text:\r\n                    this.CurrentData = new Text(this.context, { x_offset: this.x_offset, y_offset: this.y_offset });\r\n                    break;\r\n                case this.modes.x:\r\n                    this.CurrentData = new X(this.context, { x_offset: this.x_offset, y_offset: this.y_offset });\r\n                    break;\r\n                default:\r\n                case this.modes.none:\r\n                    this.CurrentData = null;\r\n                    break;\r\n            }\r\n        }\r\n        return this._currentData;\r\n    }\r\n\r\n    set CurrentData(value) {\r\n        if (null !== this._currentData) {\r\n            this._currentData.Destroy();\r\n        }\r\n        this._currentData = value;\r\n    }\r\n\r\n    SetMode(mode) {\r\n        this.CloseCurrentData();\r\n        this.DestroyCurrentData();\r\n        this.mode = mode;\r\n        this.ClearContext(this.context);\r\n        this.DrawToContext(this.context);\r\n    }\r\n\r\n    Undo() {\r\n        if (this.History.length > this.undoLevel) {\r\n            this.undoLevel++;\r\n            this.ClearContext(this.context);\r\n            this.DrawToContext(this.context);\r\n        }\r\n    }\r\n    Redo() {\r\n        if (this.undoLevel > 0) {\r\n            this.undoLevel--;\r\n            this.ClearContext(this.context);\r\n            this.DrawToContext(this.context);\r\n        }\r\n    }\r\n\r\n    get SVG() {\r\n        //Create a new mock canvas context. Pass in your desired width and height for your svg document.\r\n        var ctx = new C2S(this.canvas.width, this.canvas.height);\r\n        this.DrawToContext(ctx);\r\n        return ctx.getSerializedSvg();\r\n\r\n        //switch (type) {\r\n        //    case \"serialized\":\r\n        //        return ctx.getSerializedSvg();\r\n        //        break;\r\n        //    case \"dom\":\r\n        //    default:\r\n        //        return ctx.getSvg();\r\n\r\n        //}\r\n\r\n    }\r\n\r\n    get MarkerPoint() {\r\n        if (this.History[0]) {\r\n            return this.History[0].MarkerPoint;\r\n        }\r\n        //else if (this._currentData.IsValid) {\r\n        //    return this._currentData.MarkerPoint;\r\n        //}\r\n    }\r\n\r\n    DrawToContext(ctx) {\r\n        this.History.slice(0, this.History.length - this.undoLevel).forEach((markupData) => {\r\n            ctx.save();\r\n            markupData.DrawToContext(ctx);\r\n            ctx.restore();\r\n        });\r\n        if (null != this._currentData && this._currentData.IsValid) {\r\n            ctx.save();\r\n            return this._currentData.DrawToContext(ctx);\r\n            ctx.restore();\r\n        }\r\n        return ctx;\r\n    }\r\n    ClearContext(ctx) {\r\n        // Store the current transformation matrix\r\n        ctx.save();\r\n\r\n        // Use the identity matrix while clearing the canvas\r\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        ctx.clearRect(0, 0, ctx.canvas.clientWidth, ctx.canvas.clientHeight);\r\n\r\n        // Restore the transform\r\n        ctx.restore();\r\n    }\r\n\r\n    Destroy() {\r\n        this.History.forEach((m) => { m.Destroy(); })\r\n        if (null != this._currentData) {\r\n            this._currentData.Destroy();\r\n        }\r\n    }\r\n}\r\n\r\nclass MarkupData {\r\n    constructor(context, _opt = {}) {\r\n        if (!(this instanceof MarkupData)) return new MarkupData(_opt);\r\n\r\n        this.options = Object.assign({\r\n            x_offset: 0,\r\n            y_offset: 0\r\n        }, _opt);\r\n\r\n        this.context = context;\r\n\r\n\r\n        this.color = this.options.color || 'red';\r\n        this.s_width = this.options.width || 2;\r\n\r\n        this.context.strokeStyle = this.color;\r\n        this.context.lineWidth = this.s_width;\r\n\r\n        this.x_offset = this.options.x_offset;\r\n        this.y_offset = this.options.y_offset;\r\n\r\n        this.EventLocation = new Point(null, null);\r\n        this._finished = false;\r\n        this._isValid = false;\r\n\r\n        this.TouchMouseHandler = (e) => {\r\n            this.CaptureLocation(e);\r\n            this.HandleTouchEvent(e);\r\n        }\r\n    }\r\n\r\n    CaptureLocation(e) {\r\n        var ret = { x: null, y: null };\r\n        if (e.type === \"touchmove\" || e.type === \"touchstart\") {\r\n            //HANDLE MULTITOCH\r\n            //SHIFT FOR FINGERS\r\n            this.EventLocation.x = e.touches[0].pageX + 0.3;\r\n            this.EventLocation.y = e.touches[0].pageY + 0.3;\r\n        } else {\r\n            this.EventLocation.x = e.pageX;\r\n            this.EventLocation.y = e.pageY;\r\n        }\r\n    }\r\n\r\n    get Finished() {\r\n        return this._finished;\r\n    }\r\n\r\n    Finish() {\r\n        if (this.IsValid) {\r\n            this.TempContext.closePath();\r\n            this.TempCanvas.remove();\r\n            this.DrawToContext(this.context);\r\n\r\n            this._finished = true;\r\n        }\r\n    }\r\n\r\n    get IsValid(){\r\n        return this._isValid;\r\n    }\r\n\r\n    DrawToContext(ctx) {\r\n        //ABSTRACT\r\n        //DRAW DATA INTO CONTEXT\r\n    }\r\n\r\n    ClearContext(ctx) {\r\n        // Store the current transformation matrix\r\n        ctx.save();\r\n\r\n        // Use the identity matrix while clearing the canvas\r\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        ctx.clearRect(0, 0, ctx.canvas.clientWidth, ctx.canvas.clientHeight);\r\n\r\n        // Restore the transform\r\n        ctx.restore();\r\n    }\r\n\r\n    RedrawToContext(ctx) {\r\n        this.ClearContext(ctx) \r\n        this.DrawToContext(ctx);\r\n    }\r\n\r\n    Destroy() {\r\n        //ABSTRACT\r\n        //CLEAN UP\r\n        if (this.tempCanvas) {\r\n            this.tempCanvas.remove();\r\n        }\r\n    }\r\n\r\n    get TempCanvas() {\r\n\r\n        if (!this.tempCanvas) {\r\n            //create a new canvas\r\n            this.tempCanvas = this.context.canvas.cloneNode();\r\n            this.tempCanvas.style.pointerEvents = 'none';\r\n            this.tempCanvas.style.position = 'absolute';\r\n            this.tempCanvas.style.top = 0;\r\n            this.tempCanvas.style.left = 0;\r\n\r\n            // ...then set the internal size to match\r\n            this.tempCanvas.width = this.context.canvas.offsetWidth;\r\n            this.tempCanvas.height = this.context.canvas.offsetHeight;\r\n\r\n\r\n            this.context.canvas.parentNode.appendChild(this.tempCanvas);\r\n        }\r\n        return this.tempCanvas;\r\n    }\r\n\r\n    get TempContext() {\r\n        if (!this.tempContext) {\r\n            this.tempContext = this.TempCanvas.getContext(\"2d\");\r\n            this.tempContext.canvas.width = this.context.canvas.clientWidth;\r\n            this.tempContext.canvas.height = this.context.canvas.clientHeight;\r\n        }\r\n        return this.tempContext;\r\n    }\r\n\r\n    get FirstPoint() {\r\n        if (null !== this.points) {\r\n            return this.points[0];\r\n        } else {\r\n            return new Point(0, 0);\r\n        }\r\n    } \r\n\r\n    get MarkerPoint() {\r\n        return this.FirstPoint;\r\n    } \r\n\r\n    DrawAtAngle(ctx, point, theta, rotated_action) {\r\n        this.RotateContext(ctx, point, theta);\r\n        rotated_action();\r\n        this.RotateContext(ctx, point, -theta);\r\n    }\r\n\r\n    RotateContext(ctx, point, theta) {\r\n        let trans_x = point.x * Math.cos(theta) - point.y * Math.sin(theta);\r\n        let trans_y = point.y * Math.cos(theta) + point.x * Math.sin(theta);\r\n\r\n        ctx.translate(point.x - trans_x, point.y - trans_y);\r\n        ctx.rotate(theta);\r\n    }\r\n\r\n}\r\n\r\nclass OnePointMarkup extends MarkupData {\r\n\r\n    constructor(markup, _opt = {}) {\r\n        super(markup, _opt);\r\n\r\n        this.point = null;\r\n    }\r\n\r\n    HandleTouchEvent(e) {\r\n        switch (e.type) {\r\n            case \"touchstart\":\r\n                this.point = new Point(this.EventLocation.x, this.EventLocation.y);\r\n                this.RedrawToContext(this.TempContext);\r\n                break;\r\n\r\n            case \"mousedown\":\r\n                if (1 === e.buttons) {\r\n                    this.point = new Point(this.EventLocation.x, this.EventLocation.y);\r\n                }\r\n                this.RedrawToContext(this.TempContext);\r\n                break;\r\n\r\n            case \"touchmove\":\r\n            case \"mousemove\":\r\n            case \"touchend\":\r\n            case \"mouseleave\":\r\n            case \"mouseup\":\r\n                this.Finish();\r\n                break;\r\n\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n\r\n    get IsValid() {\r\n        return this.point;\r\n    }\r\n\r\n    get FirstPoint() {\r\n        if (this.IsValid) {\r\n            return this.point;\r\n        }\r\n    }\r\n}\r\n\r\nclass TwoPointMarkup extends MarkupData {\r\n\r\n    constructor(markup, _opt = {}) {\r\n        super(markup, _opt);\r\n\r\n        this.start = null;\r\n        this.end = null;\r\n    }\r\n\r\n    HandleTouchEvent(e) {\r\n        switch (e.type) {\r\n            case \"touchstart\":\r\n                //this.start = new Point(this.EventLocation.x, this.EventLocation.y);\r\n                this.StartTouch(e);\r\n                break;\r\n\r\n            case \"mousedown\":\r\n                if (1 === e.buttons) {\r\n                    //this.start = new Point(this.EventLocation.x, this.EventLocation.y);\r\n                    this.StartTouch(e);\r\n                }\r\n                break;\r\n\r\n            case \"touchmove\":\r\n                this.MoveTouch(e);\r\n                //this.end = new Point(this.EventLocation.x, this.EventLocation.y);\r\n                //this.RedrawToContext(this.TempContext);\r\n                break;\r\n\r\n            case \"mousemove\":\r\n                if (1 === e.buttons) {\r\n                    this.MoveTouch(e);\r\n                    //this.end = new Point(this.EventLocation.x, this.EventLocation.y);\r\n                    //this.RedrawToContext(this.TempContext);\r\n                }\r\n                break;\r\n\r\n            case \"touchend\":\r\n            case \"mouseleave\":\r\n            case \"mouseup\":\r\n                this.StopTouch(e);\r\n                //this.Finish();\r\n                break;\r\n\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n\r\n    StartTouch(e) {\r\n        this.start = new Point(this.EventLocation.x, this.EventLocation.y);\r\n    }\r\n\r\n    MoveTouch(e) {\r\n        this.end = new Point(this.EventLocation.x, this.EventLocation.y);\r\n        this.RedrawToContext(this.TempContext);\r\n    }\r\n\r\n    StopTouch(e) {\r\n        this.Finish();\r\n    }\r\n\r\n    get IsValid() {\r\n        return (this.start !== null && this.end !== null);\r\n    }\r\n\r\n\r\n    get MarkerPoint() {\r\n        if (this.IsValid) {\r\n            return this.start;\r\n        }\r\n    }\r\n}\r\n\r\nclass ContinuousMarkup extends MarkupData {\r\n    constructor(markup, _opt = {}) {\r\n        super(markup, _opt);\r\n\r\n        this.points = null;\r\n\r\n\r\n    }\r\n    HandleTouchEvent(e) {\r\n\r\n\r\n        switch (e.type) {\r\n            case \"touchstart\":\r\n                this.AddPoint(this.EventLocation.x, this.EventLocation.y);\r\n                break;\r\n\r\n            case \"mousedown\":\r\n                if (1 === e.buttons) {\r\n                    this.AddPoint(this.EventLocation.x, this.EventLocation.y);\r\n                }\r\n                break;\r\n\r\n            case \"touchmove\":\r\n                this.AddPoint(this.EventLocation.x, this.EventLocation.y);\r\n                break;\r\n\r\n            case \"mousemove\":\r\n                if (1 === e.buttons) {\r\n                    this.AddPoint(this.EventLocation.x, this.EventLocation.y);\r\n                }\r\n                break;\r\n\r\n            case \"touchend\":\r\n            case \"mouseleave\":\r\n            case \"mouseup\":\r\n                this.Finish()\r\n                break;\r\n\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n\r\n    AddPoint(_x, _y) {\r\n        if (_x && _y) {\r\n            let x, y;\r\n            x = _x - this.x_offset;\r\n            y = _y - this.y_offset;\r\n\r\n            if (!this.points) {\r\n                //first point\r\n                //this.context.closePath();\r\n                //this.context.beginPath();\r\n                this.points = [];\r\n                //this.context.moveTo(x, y);\r\n            }\r\n            //else {\r\n            //    //next point\r\n            //    this.context.lineTo(x, y);\r\n            //    this.context.stroke();\r\n            //}\r\n            this.points.push({ x: x, y: y });\r\n\r\n            this.RedrawToContext(this.TempContext);\r\n        }\r\n    }\r\n\r\n    get IsValid() {\r\n        if (this.points) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    get FirstPoint() {\r\n        if (this.points) {\r\n            return this.points[0];\r\n        }\r\n    }\r\n}\r\n\r\nclass Stroke extends ContinuousMarkup {\r\n    constructor(markup, _opt = {}) {\r\n        super(markup, _opt);\r\n    }\r\n\r\n    DrawToContext(ctx) {\r\n        //DRAW DATA INTO CONTEXT\r\n        ctx.beginPath();\r\n        ctx.strokeStyle = this.color;\r\n        ctx.lineWidth = this.s_width;\r\n        ctx.moveTo(this.points[0].x, this.points[0].y);\r\n        for (var j = 1; j < this.points.length; j++) { //each stroke\r\n            ctx.lineTo(this.points[j].x, this.points[j].y);\r\n            ctx.stroke();\r\n        }\r\n        ctx.closePath();\r\n    }\r\n}\r\n\r\nclass Line extends TwoPointMarkup {\r\n    constructor(markup, _opt = {}) {\r\n        super(markup, _opt);\r\n    }\r\n\r\n    DrawToContext(ctx) {\r\n        //DRAW DATA INTO CONTEXT\r\n        ctx.beginPath();\r\n\r\n        ctx.strokeStyle = this.color;\r\n        ctx.lineWidth = this.s_width;\r\n\r\n        ctx.moveTo(this.start.x, this.start.y);\r\n        ctx.lineTo(this.end.x, this.end.y);\r\n        ctx.stroke();\r\n\r\n        ctx.closePath();\r\n    }\r\n}\r\n\r\nclass Rectangle extends TwoPointMarkup {\r\n    constructor(markup, _opt = {}) {\r\n        super(markup, _opt);\r\n    }\r\n\r\n    DrawToContext(ctx) {\r\n        //DRAW DATA INTO CONTEXT\r\n        ctx.beginPath();\r\n\r\n        ctx.strokeStyle = this.color;\r\n        ctx.lineWidth = this.s_width;\r\n\r\n        ctx.moveTo(this.start.x, this.start.y);\r\n        ctx.lineTo(this.end.x, this.start.y);\r\n        ctx.lineTo(this.end.x, this.end.y);\r\n        ctx.lineTo(this.start.x, this.end.y);\r\n        ctx.lineTo(this.start.x, this.start.y);\r\n\r\n        //ctx.strokeRect(this.start.x, this.start.y, this.end.x - this.start.x, this.end.y - this.start.y);\r\n\r\n        ctx.stroke();\r\n\r\n        ctx.closePath();\r\n    }\r\n}\r\n\r\nclass Circle extends TwoPointMarkup {\r\n    constructor(markup, _opt = {}) {\r\n        super(markup, _opt);       \r\n\r\n    }\r\n\r\n    DrawToContext(ctx) {\r\n        //DRAW DATA INTO CONTEXT\r\n        ctx.beginPath();\r\n\r\n        ctx.strokeStyle = this.color;\r\n        ctx.lineWidth = this.s_width;\r\n        ctx.fillStyle = \"\";\r\n\r\n        let radius = Math.sqrt(Math.pow(this.start.x - this.end.x, 2) + Math.pow(this.start.y - this.end.y,2))\r\n        ctx.arc(this.start.x, this.start.y, radius, 0,2*Math.PI);\r\n        \r\n        ctx.stroke();\r\n\r\n        ctx.closePath();\r\n    }\r\n}\r\n\r\nclass Text extends TwoPointMarkup {\r\n    constructor(markup, _opt = {}) {\r\n        super(markup, _opt);\r\n\r\n        this.opts = Object.assign({\r\n            font: '',\r\n            fillStyle: \"\",\r\n            fillText: \"\"\r\n        }, this.opts);\r\n\r\n        this.Reset();\r\n    }\r\n\r\n    Reset() {\r\n        this.lines = [];\r\n        this.start = null;\r\n        this.end = null;\r\n        this.stopping = false;\r\n        this.ClearContext(this.TempContext);\r\n        this.DrawToContext = this.DrawCursorToContext;\r\n    }\r\n\r\n    async StopTouch(e) {\r\n        if (super.IsValid && !this.stopping) {\r\n            this.stopping = true;\r\n            this.DrawToContext = this.DrawTextToContext;\r\n\r\n            try {\r\n                var text = await Utility.modal.InputMultiline();\r\n                this.lines = text.split(\"\\n\");\r\n            }\r\n            catch (err)\r\n            {\r\n                \r\n            }\r\n\r\n            if (!this.IsValid) {\r\n                this._finished = true;\r\n                this.Reset();\r\n                return;\r\n            }\r\n        }\r\n        super.StopTouch(e);\r\n    }\r\n\r\n    get FontHeight() {\r\n        return Math.sqrt(Math.pow(this.start.x - this.end.x, 2) + Math.pow(this.start.y - this.end.y, 2));\r\n    }\r\n\r\n    get LineAngle() {\r\n        let theta = Math.atan2(-(this.start.y - this.end.y), -(this.start.x - this.end.x));\r\n\r\n        return theta;\r\n    }\r\n\r\n    get FontAngle() {\r\n        //90 deg from line angle\r\n        let theta = this.LineAngle;// - Math.PI / 2; \r\n\r\n        //SNAP TO NEAREST 90\r\n        let snap_angle = Math.PI / 180.0 *5.0;\r\n        if (0 - snap_angle <= theta && theta <= 0 + snap_angle) {\r\n            theta= 0;\r\n        } else if (-Math.PI / 2 - snap_angle <= theta && theta <= -Math.PI / 2 + snap_angle) {\r\n            theta = -Math.PI / 2;\r\n        } else if (-Math.PI + snap_angle >= theta || theta >= Math.PI - snap_angle) {\r\n            theta = Math.PI;\r\n        } else if (Math.PI / 2 - snap_angle <= theta && theta <= Math.PI / 2 + snap_angle) {\r\n            theta = Math.PI / 2;\r\n        }\r\n\r\n        //else if (Math.PI / 2 - snap_angle <= theta && theta <= Math.PI / 2 + snap_angle) {\r\n        //    theta = Math.PI / 2;\r\n        //} else if (-Math.PI / 2 - snap_angle <= theta && theta <= -Math.PI / 2 + snap_angle) {\r\n        //    theta = -Math.PI / 2;\r\n        //} \r\n        //console.log(`Font angle: ${theta}`);\r\n        return theta - Math.PI / 2; \r\n    }\r\n\r\n    get IsValid() {\r\n        return this.lines.join('').length > 0 && super.IsValid;\r\n    }\r\n\r\n    DrawCursorToContext(ctx) {\r\n        //DRAW DATA INTO CONTEXT\r\n        ctx.beginPath();\r\n\r\n        ctx.strokeStyle = this.color;\r\n        ctx.lineWidth = this.s_width;\r\n\r\n        ctx.moveTo(this.start.x, this.start.y);\r\n        ctx.lineTo(this.end.x, this.end.y);\r\n        ctx.stroke();\r\n\r\n\r\n        ctx.font = `${Math.round(this.FontHeight * 1.50)}px Arial`;\r\n        ctx.fillStyle = \"red\";\r\n\r\n        this.DrawAtAngle(ctx, this.end, this.FontAngle, () => {\r\n            ctx.moveTo(this.end.x + 5, this.end.y);\r\n            ctx.lineTo(this.end.x + 50, this.end.y);\r\n            ctx.stroke();\r\n        });\r\n\r\n        ctx.closePath();\r\n    }\r\n\r\n    DrawTextToContext(ctx) {\r\n        //DRAW DATA INTO CONTEXT\r\n        let text_height = Math.round(this.FontHeight * 1.50)\r\n        ctx.font = `${text_height}px Monospace`;\r\n        ctx.fillStyle = \"red\";\r\n\r\n        let text_point = this.end;\r\n\r\n        let theta_rad = this.FontAngle;\r\n        this.RotateContext(ctx, text_point, theta_rad);\r\n        for (var i = 0; i < this.lines.length; i++) {\r\n            ctx.fillText(this.lines[i], text_point.x, text_point.y + text_height*i);\r\n        }\r\n        this.RotateContext(ctx, text_point, -theta_rad);\r\n\r\n        //if (!this.Finished) {\r\n        //    this.DrawCursorToContext(ctx);\r\n        //}\r\n        \r\n    }\r\n}\r\n\r\nclass X extends TwoPointMarkup {\r\n    constructor(markup, _opt = {}) {\r\n        super(markup, _opt);\r\n    }\r\n\r\n    DrawToContext(ctx) {\r\n        //DRAW DATA INTO CONTEXT\r\n        ctx.beginPath();\r\n\r\n        ctx.strokeStyle = this.color;\r\n        ctx.lineWidth = this.s_width;\r\n\r\n        ctx.moveTo(this.start.x, this.start.y);\r\n        ctx.lineTo(this.end.x, this.end.y);\r\n        ctx.moveTo(this.start.x, this.end.y);\r\n        ctx.lineTo(this.end.x, this.start.y);\r\n\r\n        ctx.stroke();\r\n\r\n        ctx.closePath();\r\n    }\r\n}\r\n\r\nclass Point {\r\n    constructor(x,y) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n}\r\n"],"sourceRoot":""}